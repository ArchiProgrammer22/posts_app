# Posts App
This application get data with retrofit and view in RecyclerViewList. When clicking on an element RecyclerView full information is displayed
Technologies used: Retrofit, Room, Android Architecture Components(livedata, viewModel, dataBinding), DI(Dagger), coroutines



1) Что такое ООП? Краткое описание каждого из принципов.
Объектно ореинтированная парадигма.
Наследование - каждый класс-обьъект может наследовать методы и свойства другого класса-обьекта.
Полиморфизм - (много форм) одна идея - разная реализация. Пример: базовый класс - Vehicle, у которого есть метод move() наследуется классами Car и Bike. При переопределении этих методов, реализация в каждом объекте-классе будет разная.
Инкапсуляция - объединение данных и методов(геттеры сеттеры) с возможностью сокрытия всего не нужного для использования(модификаторы доступа). С помощью этого принципа можно не задумываться над внутренней реализацией класса и просто использовать функционал этого класса
2) Что быстрее ArayList или LinkedList. Сколько выделяется ячеек при создание этих пустых листов?
ArrayList в основном быстрее чем LinkedList, не считая добавления/удаления в начало и конец, поскольку LinkedList имеет прямые ссылки(Node) на начало и конец. Во всем же остальном LinkedList проигрывает. При создании в ArrayList 10, в LinkedList выделяется 2, first Node head Node.
3) Можно ли передавать Context в ViewModel или Presenter? Если можно то как и какие бывают последствия?
Можно, но не нужно(может быть утечка памяти). Если вы хотите передать контекст, следует свою ViewModel расширить не ViewModel() а AndroidViewModel. Этот класс дает возможность передать контекст.
4)Как передать данные с Activity во Fragment и наоборот?
Через Bundle. Во фрагменте в методе onCreateView вызвать метод getAtguments и достать данные, которые вы передавали в Activity.
5) Принцыпы Solid и краткое описание. 
1.Single Responsibility - у класса должна быть только одна причина для изменения/ у класса должна быть одна цель.
2.Open Closed - класс должен быть открыт для расширения и закрыт для изменения.
3.Liskov Subnitution - методы которые используют базовый класс, должны уметь использовать класс наследник без каких либо проблем.
4.Interface Segregation - Не нужно делать слишком большие интерфейсы. Лучше разделить на более маленькие, чтобы не было ситуаций, когда мы реализуем интерфейс, а нам приходится реализовывать метод, который нам не нужен.
5.Dependency Inversion -  абстракции не должны зависеть от деталей, а вот реализация должна зависеть от абстракций. Пример interface Repositorу, ему не интересно какая именно у нас будет реализация, через локальную бд или через API. А вот RepositoryImpl реализовывает Repository.


